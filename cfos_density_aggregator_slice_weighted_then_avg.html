<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>c-fos Density 汇总器（切片内面积加权合成 → 按出现次数平均）</title>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" />
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    body { padding: 24px; }
    .dropzone { border:2px dashed #bbb; border-radius:10px; padding:22px; text-align:center; color:#666; background:#fafafa; transition:.2s; }
    .dropzone.dragover { border-color:#0d6efd; color:#0d6efd; background:#f3f8ff; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace; }
    table { font-size: 14px; }
    .smallhelp { font-size: 13px; color:#666; }
  </style>
</head>
<body>
  <div class="container-fluid" style="max-width: 1450px;">
    <div class="d-flex align-items-center justify-content-between mb-3">
      <div>
        <h1 class="h3 mb-1">c-fos density 汇总器（切片内面积加权合成 → 按出现次数平均）</h1>
        <div class="smallhelp">
          适配你说的情况：同一张切片上某些细分区会“消失”，但它们仍属于同一个更大的脑区（如 ACA / SSp / ACAd 等）。<br>
          本工具做法：先在<strong>每一张切片(Image)</strong>里，对同一<strong>合并脑区(MergedRegion)</strong>出现的所有细分项做<strong>面积加权合成</strong>，再除以 0.05mm（可改厚度），最后再除以该脑区出现的切片次数。
          <hr class="my-2">
          <div class="mono">
            slice_density_mm2 = Σ(density_mm2 × area_mm2) / Σ(area_mm2)<br>
            slice_density_mm3 = slice_density_mm2 / thickness(mm)<br>
            Avg_Density_per_mm3 = Σ(slice_density_mm3) / N_slices   (N_slices = 该脑区出现的 Image 数)
          </div>
          <div class="mt-1">
            特例：<strong>DG 不合并</strong>（DG-mo/DG-po/DG-sg 保留）；<strong>GU1/GU2/3/GU6a… 合并为 GU</strong>。
          </div>
        </div>
      </div>
      <div class="text-end">
        <button id="btnDownMerged" class="btn btn-primary" disabled>下载合并脑区CSV</button>
        <button id="btnDownSlice" class="btn btn-outline-primary ms-2" disabled>下载切片级CSV</button>
        <button id="btnDownMap" class="btn btn-outline-secondary ms-2" disabled>下载映射表CSV</button>
      </div>
    </div>

    <div class="row g-3">
      <div class="col-lg-7">
        <div id="dropzone" class="dropzone">
          <div class="mb-2">把 CSV 拖进来，或点击选择文件</div>
          <input id="fileInput" type="file" accept=".csv,text/csv" class="form-control" />
          <div class="smallhelp mt-2">
            推荐字段：<span class="mono">Image</span>, <span class="mono">AnnotationName</span>, <span class="mono">Channel</span>, <span class="mono">Density_per_mm2</span>, <span class="mono">Area_corrected</span>。<br>
            面积字段支持：<span class="mono">Area_corrected</span>（µm²，自动 ÷1e6 变 mm²）或 <span class="mono">Area_mm2</span>。<br>
            若缺面积但有 <span class="mono">Cells</span> + <span class="mono">Density_per_mm2</span>，会用 <span class="mono">Area = Cells / Density</span> 反推面积。
          </div>
        </div>
      </div>

      <div class="col-lg-5">
        <div class="card">
          <div class="card-body">
            <h2 class="h5">参数</h2>

            <div class="mb-3">
              <label for="thickness" class="form-label">切片厚度（mm）</label>
              <input id="thickness" type="number" step="0.001" min="0.001" class="form-control" value="0.05">
              <div class="smallhelp mt-1">50 µm = 0.05 mm（默认）</div>
            </div>

            <div class="mb-2">
              <div class="form-check">
                <input class="form-check-input" type="checkbox" id="optStripLayer" checked>
                <label class="form-check-label" for="optStripLayer">
                  去掉皮层层号（仅当层号前一位是小写字母，避免误伤 CA1/CA3）
                </label>
              </div>
              <div class="smallhelp">例：ACAd2/3 → ACAd；ACAv6a → ACAv；SSp-bfd6a → SSp-bfd</div>
            </div>

            <div class="mb-2">
              <div class="form-check">
                <input class="form-check-input" type="checkbox" id="optDashMerge" checked>
                <label class="form-check-label" for="optDashMerge">
                  若名称包含 “-”，合并到 “-” 前（例：SSp-bfd → SSp）
                </label>
              </div>
            </div>

            <div class="mb-2">
              <div class="form-check">
                <input class="form-check-input" type="checkbox" id="optAuto3" checked>
                <label class="form-check-label" for="optAuto3">
                  自动合并到前三个字符（例：ACAd/ACAv → ACA；VISp/VISal → VIS；ORBl/ORBvl → ORB）
                </label>
              </div>
            </div>

            <div class="mb-3">
              <div class="form-check">
                <input class="form-check-input" type="checkbox" id="optAuto2" checked>
                <label class="form-check-label" for="optAuto2">
                  自动合并两字母核团前缀（AI、SC、LG…）
                </label>
              </div>
              <label for="auto2List" class="form-label mt-2 mb-1">两字母前缀白名单（逗号分隔）</label>
              <input id="auto2List" class="form-control" value="AI, SC, LG, LS, MG, MM, SN, TT, IC, EP, GP, AM, PM, TM">
              <div class="smallhelp mt-1">默认不包含 MO（避免 MOp/MOs 合并）与 PV（避免 PVH/PVT 混合）。</div>
            </div>

            <div class="mb-2">
              <label for="overridePrefixes" class="form-label">手动覆盖：优先合并前缀（可选）</label>
              <input id="overridePrefixes" class="form-control" placeholder="例如：ACAd, ACA, SSp, VIS">
              <div class="smallhelp mt-1">写在这里的前缀会优先合并（最高优先级）。</div>
            </div>

            <div class="mt-3" id="warnBox"></div>
          </div>
        </div>
      </div>
    </div>

    <div class="mt-4">
      <div class="d-flex align-items-center justify-content-between">
        <h2 class="h5 mb-2">结果预览</h2>
        <div id="status" class="smallhelp"></div>
      </div>

      <ul class="nav nav-tabs" role="tablist">
        <li class="nav-item" role="presentation">
          <button class="nav-link active" data-bs-toggle="tab" data-bs-target="#pane-merged" type="button" role="tab">合并脑区（最终）</button>
        </li>
        <li class="nav-item" role="presentation">
          <button class="nav-link" data-bs-toggle="tab" data-bs-target="#pane-slice" type="button" role="tab">切片级（中间结果）</button>
        </li>
      </ul>

      <div class="tab-content border border-top-0 p-2">
        <div class="tab-pane fade show active" id="pane-merged" role="tabpanel">
          <div class="smallhelp my-2">
            最终输出：<span class="mono">Avg_Density_per_mm3</span>（切片内面积加权合成后，再按出现次数平均）。
          </div>
          <div class="table-responsive">
            <table class="table table-sm table-striped align-middle" id="tblMerged">
              <thead>
                <tr>
                  <th>MergedRegion</th>
                  <th>Channel</th>
                  <th class="text-end">N_slices</th>
                  <th class="text-end">Avg_Density_per_mm3</th>
                  <th class="text-end">Sum_SliceDensity_per_mm3</th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>
        </div>

        <div class="tab-pane fade" id="pane-slice" role="tabpanel">
          <div class="smallhelp my-2">
            切片级：每行对应一个 <span class="mono">Image + MergedRegion + Channel</span> 的合成结果（面积加权）。
          </div>
          <div class="table-responsive">
            <table class="table table-sm table-striped align-middle" id="tblSlice">
              <thead>
                <tr>
                  <th>Image</th>
                  <th>MergedRegion</th>
                  <th>Channel</th>
                  <th class="text-end">SumArea_mm2</th>
                  <th class="text-end">slice_density_mm2</th>
                  <th class="text-end">slice_density_mm3</th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>
        </div>
      </div>
    </div>

  </div>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <script>
    const dz = document.getElementById('dropzone');
    const fileInput = document.getElementById('fileInput');

    const thicknessEl = document.getElementById('thickness');
    const optStripLayerEl = document.getElementById('optStripLayer');
    const optDashMergeEl = document.getElementById('optDashMerge');
    const optAuto3El = document.getElementById('optAuto3');
    const optAuto2El = document.getElementById('optAuto2');
    const auto2ListEl = document.getElementById('auto2List');
    const overridePrefixesEl = document.getElementById('overridePrefixes');

    const statusEl = document.getElementById('status');
    const warnBox = document.getElementById('warnBox');

    const mergedBody = document.querySelector('#tblMerged tbody');
    const sliceBody = document.querySelector('#tblSlice tbody');

    const btnDownMerged = document.getElementById('btnDownMerged');
    const btnDownSlice = document.getElementById('btnDownSlice');
    const btnDownMap = document.getElementById('btnDownMap');

    let lastRawRows = null;
    let lastMerged = null;
    let lastSlice = null;
    let lastMap = null;

    function setStatus(msg, isError=false){
      statusEl.textContent = msg;
      statusEl.className = 'smallhelp ' + (isError ? 'text-danger' : '');
    }
    function setWarn(html){
      warnBox.innerHTML = html || '';
    }

    function toNumber(x){
      if (x === null || x === undefined) return NaN;
      if (typeof x === 'number') return x;
      const s = String(x).trim();
      if (s === '') return NaN;
      const v = Number(s);
      return Number.isFinite(v) ? v : NaN;
    }
    function getThickness(){
      const t = toNumber(thicknessEl.value);
      if (!Number.isFinite(t) || t <= 0) return null;
      return t;
    }
    function escapeHtml(s){
      return String(s ?? '').replace(/[&<>"']/g, (m) => ({
        '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'
      }[m]));
    }
    function fmt(x){
      if (x === '' || x === null || x === undefined) return '';
      const v = toNumber(x);
      if (!Number.isFinite(v)) return '';
      if (Math.abs(v) >= 1000) return v.toFixed(2);
      if (Math.abs(v) >= 100) return v.toFixed(3);
      return v.toFixed(4);
    }

    function normalizeRow(r){
      const AnnotationName = r.AnnotationName ?? r.annotationname ?? r.Annotation ?? r.Region ?? r.region;
      const Channel = r.Channel ?? r.channel ?? 'NA';
      const Cells = toNumber(r.Cells ?? r.cells);
      const Density_per_mm2 = toNumber(r.Density_per_mm2 ?? r.density_per_mm2 ?? r.Density ?? r.density);
      const Area_corrected = toNumber(r.Area_corrected ?? r.area_corrected ?? r.AreaCorrected);
      const Area_mm2 = toNumber(r.Area_mm2 ?? r.area_mm2);
      const Image = r.Image ?? r.image ?? null;
      return { AnnotationName, Channel, Cells, Density_per_mm2, Area_corrected, Area_mm2, Image };
    }

    function parseList(raw){
      const list = String(raw ?? '').split(',').map(s => s.trim()).filter(Boolean);
      list.sort((a,b)=>b.length-a.length);
      return list;
    }

    function stripCorticalLayer(name){
      const m = name.match(/(2\/3|6a|6b|1|4|5|6)$/);
      if (!m) return name;
      const suf = m[0];
      const idx = name.length - suf.length;
      if (idx > 0 && /[a-z]/.test(name[idx-1])) return name.slice(0, idx);
      return name;
    }

    // Step 1: prepare "sub" name (strip layer etc), with DG/GU specials
    function subRegionFromName(name){
      let n = String(name ?? '').trim();
      if (!n) return '';

      // DG 不合并：保留 DG-mo/DG-po/DG-sg
      if (n === 'DG' || n.startsWith('DG-')) return n;

      // GU 特例：GU1/GU2/3/GU6a… 统一归 GU
      if (/^GU(\d|$)/.test(n)) return 'GU';

      if (optStripLayerEl.checked) n = stripCorticalLayer(n);
      return n;
    }

    // Step 2: map sub -> merged (the big region you want)
    function mergedRegionFromSub(sub){
      let n = String(sub ?? '').trim();
      if (!n) return '';

      // DG 不合并
      if (n === 'DG' || n.startsWith('DG-')) return n;

      // manual override first
      const overrides = parseList(overridePrefixesEl.value);
      for (const p of overrides){
        if (n.startsWith(p)) return p;
      }

      if (optDashMergeEl.checked && n.includes('-')) n = n.split('-')[0].trim();

      if (optAuto2El.checked && n.length >= 3){
        const p2 = n.slice(0,2);
        const c3 = n[2];
        const allow2 = new Set(parseList(auto2ListEl.value).map(x => x.toUpperCase()));
        if (/^[A-Z]{2}$/.test(p2) && /[a-z]/.test(c3) && allow2.has(p2)) return p2;
      }

      if (optAuto3El.checked && n.length >= 3){
        const p3 = n.slice(0,3);
        if (/^[A-Za-z]{3}$/.test(p3)) return p3;
      }

      return n;
    }

    function computeAll(rows){
      const thickness = getThickness();
      if (!thickness) throw new Error('切片厚度（mm）无效，请填写大于0的数字。');

      const cleaned = rows.map(normalizeRow).filter(r => r.AnnotationName != null && String(r.AnnotationName).trim() !== '');
      if (!cleaned.length) throw new Error('未检测到 AnnotationName。请确认 CSV 包含列：AnnotationName。');

      let missingImage = 0;
      let usedAreaFromCells = 0;
      let skipped = 0;

      // mapping table: AnnotationName -> SubRegion -> MergedRegion
      const mapRows = new Map();

      // slice aggregation: key = Image||MergedRegion||Channel
      const sliceMap = new Map();

      for (const r of cleaned){
        const anno = String(r.AnnotationName).trim();
        const sub = subRegionFromName(anno);
        if (!sub) { skipped++; continue; }
        const merged = mergedRegionFromSub(sub);
        mapRows.set(anno, {SubRegion: sub, MergedRegion: merged});

        const img = (r.Image == null || String(r.Image).trim()==='') ? null : String(r.Image).trim();
        if (!img) missingImage += 1;
        const imgKey = img || '__NO_IMAGE__';

        const ch = String(r.Channel ?? 'NA').trim();
        const key = imgKey + '||' + merged + '||' + ch;

        // area in mm2
        let area_mm2 = NaN;
        if (Number.isFinite(r.Area_corrected)) area_mm2 = r.Area_corrected / 1e6;
        else if (Number.isFinite(r.Area_mm2)) area_mm2 = r.Area_mm2;

        // density in mm2
        let d_mm2 = r.Density_per_mm2;

        // if density missing but have cells+area -> compute density
        if (!Number.isFinite(d_mm2) && Number.isFinite(r.Cells) && Number.isFinite(area_mm2) && area_mm2 > 0){
          d_mm2 = r.Cells / area_mm2;
        }

        // if area missing but have cells+density -> infer area
        if (!Number.isFinite(area_mm2) && Number.isFinite(r.Cells) && Number.isFinite(d_mm2) && d_mm2 > 0){
          area_mm2 = r.Cells / d_mm2;
          usedAreaFromCells += 1;
        }

        if (!Number.isFinite(area_mm2) || area_mm2 <= 0 || !Number.isFinite(d_mm2)){
          skipped += 1;
          continue;
        }

        const numer = d_mm2 * area_mm2; // density * area

        if (!sliceMap.has(key)){
          sliceMap.set(key, {
            Image: imgKey,
            MergedRegion: merged,
            Channel: ch,
            SumArea_mm2: 0,
            SumNumer: 0
          });
        }
        const g = sliceMap.get(key);
        g.SumArea_mm2 += area_mm2;
        g.SumNumer += numer;
      }

      const sliceRows = Array.from(sliceMap.values()).map(g => {
        const slice_density_mm2 = g.SumArea_mm2 > 0 ? (g.SumNumer / g.SumArea_mm2) : '';
        const slice_density_mm3 = g.SumArea_mm2 > 0 ? (slice_density_mm2 / thickness) : '';
        return {
          Image: g.Image,
          MergedRegion: g.MergedRegion,
          Channel: g.Channel,
          SumArea_mm2: g.SumArea_mm2,
          slice_density_mm2,
          slice_density_mm3
        };
      }).sort((a,b)=> (a.Channel.localeCompare(b.Channel) || a.MergedRegion.localeCompare(b.MergedRegion) || a.Image.localeCompare(b.Image)));

      // merged aggregation across slices: key = MergedRegion||Channel
      const mergedMap = new Map();
      for (const s of sliceRows){
        const key = s.MergedRegion + '||' + s.Channel;
        if (!mergedMap.has(key)){
          mergedMap.set(key, {MergedRegion: s.MergedRegion, Channel: s.Channel, SliceSet: new Set(), Sum: 0});
        }
        const g = mergedMap.get(key);
        g.SliceSet.add(s.Image);
        g.Sum += toNumber(s.slice_density_mm3);
      }

      const mergedRows = Array.from(mergedMap.values()).map(g => {
        const N_slices = g.SliceSet.size;
        const avg = N_slices ? (g.Sum / N_slices) : '';
        return {
          MergedRegion: g.MergedRegion,
          Channel: g.Channel,
          N_slices,
          Avg_Density_per_mm3: avg,
          Sum_SliceDensity_per_mm3: g.Sum
        };
      }).sort((a,b)=> (a.Channel.localeCompare(b.Channel) || a.MergedRegion.localeCompare(b.MergedRegion)));

      const mapOut = Array.from(mapRows.entries()).sort((a,b)=>a[0].localeCompare(b[0])).map(([AnnotationName, v]) => ({
        AnnotationName, SubRegion: v.SubRegion, MergedRegion: v.MergedRegion
      }));

      const warns = [];
      if (missingImage > 0){
        warns.push(`发现 <span class="mono">${missingImage}</span> 行缺少 Image：这些行会被当作同一张虚拟切片 <span class="mono">__NO_IMAGE__</span> 处理（会影响 N_slices）。建议保留 Image 列。`);
      }
      if (usedAreaFromCells > 0){
        warns.push(`有 <span class="mono">${usedAreaFromCells}</span> 行缺少面积，但用 <span class="mono">Area = Cells / Density_per_mm2</span> 反推了面积。`);
      }
      if (skipped > 0){
        warns.push(`有 <span class="mono">${skipped}</span> 行无法得到面积或密度（被跳过）。`);
      }

      return {mergedRows, sliceRows, mapOut, warns};
    }

    function renderMerged(rows){
      mergedBody.innerHTML = '';
      for (const r of rows.slice(0, 8000)){
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${escapeHtml(r.MergedRegion)}</td>
          <td>${escapeHtml(r.Channel)}</td>
          <td class="text-end">${r.N_slices}</td>
          <td class="text-end">${fmt(r.Avg_Density_per_mm3)}</td>
          <td class="text-end">${fmt(r.Sum_SliceDensity_per_mm3)}</td>
        `;
        mergedBody.appendChild(tr);
      }
    }

    function renderSlice(rows){
      sliceBody.innerHTML = '';
      for (const r of rows.slice(0, 10000)){
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${escapeHtml(r.Image)}</td>
          <td>${escapeHtml(r.MergedRegion)}</td>
          <td>${escapeHtml(r.Channel)}</td>
          <td class="text-end">${fmt(r.SumArea_mm2)}</td>
          <td class="text-end">${fmt(r.slice_density_mm2)}</td>
          <td class="text-end">${fmt(r.slice_density_mm3)}</td>
        `;
        sliceBody.appendChild(tr);
      }
    }

    function downloadCSV(rows, filename, header){
      const lines = [header.join(',')];
      for (const r of rows){
        const line = header.map(h => {
          const v = r[h];
          const s = (v === null || v === undefined) ? '' : String(v);
          if (s.includes(',') || s.includes('"') || s.includes('\n')) return '"' + s.replaceAll('"','""') + '"';
          return s;
        }).join(',');
        lines.push(line);
      }
      const blob = new Blob([lines.join('\n')], {type: 'text/csv;charset=utf-8;'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    function recompute(){
      if (!lastRawRows) return;
      try{
        const {mergedRows, sliceRows, mapOut, warns} = computeAll(lastRawRows);

        if (!mergedRows.length){
          setStatus('没有可用结果：请确认至少包含 Density_per_mm2 + 面积（或 Cells 可反推）。', true);
          btnDownMerged.disabled = true;
          btnDownSlice.disabled = true;
          btnDownMap.disabled = true;
          mergedBody.innerHTML = '';
          sliceBody.innerHTML = '';
          setWarn('');
          return;
        }

        lastMerged = mergedRows;
        lastSlice = sliceRows;
        lastMap = mapOut;

        renderMerged(mergedRows);
        renderSlice(sliceRows);

        btnDownMerged.disabled = false;
        btnDownSlice.disabled = false;
        btnDownMap.disabled = false;

        setStatus(`完成：合并脑区 ${mergedRows.length} 行；切片级 ${sliceRows.length} 行；映射表 ${mapOut.length} 个原始脑区。`);

        if (warns && warns.length){
          setWarn('<div class="alert alert-warning smallhelp mb-0"><div class="fw-semibold mb-1">提示</div><ul class="mb-0"><li>' + warns.join('</li><li>') + '</li></ul></div>');
        } else {
          setWarn('');
        }

      }catch(e){
        console.error(e);
        setStatus('处理失败：' + e.message, true);
        btnDownMerged.disabled = true;
        btnDownSlice.disabled = true;
        btnDownMap.disabled = true;
        mergedBody.innerHTML = '';
        sliceBody.innerHTML = '';
        setWarn('');
      }
    }

    function handleFile(file){
      setStatus('正在读取 CSV…');
      Papa.parse(file, {
        header: true,
        dynamicTyping: false,
        skipEmptyLines: true,
        complete: (res) => {
          lastRawRows = res.data || [];
          recompute();
        }
      });
    }

    fileInput.addEventListener('change', (e) => {
      const f = e.target.files && e.target.files[0];
      if (f) handleFile(f);
    });

    ['dragenter','dragover'].forEach(evt => {
      dz.addEventListener(evt, (e) => { e.preventDefault(); e.stopPropagation(); dz.classList.add('dragover'); });
    });
    ['dragleave','drop'].forEach(evt => {
      dz.addEventListener(evt, (e) => { e.preventDefault(); e.stopPropagation(); dz.classList.remove('dragover'); });
    });
    dz.addEventListener('drop', (e) => {
      const f = e.dataTransfer.files && e.dataTransfer.files[0];
      if (f) { fileInput.value=''; handleFile(f); }
    });

    [thicknessEl, optStripLayerEl, optDashMergeEl, optAuto3El, optAuto2El, auto2ListEl, overridePrefixesEl].forEach(el => {
      el.addEventListener('change', () => { if (lastRawRows) recompute(); });
      el.addEventListener('input', () => { if (lastRawRows) recompute(); });
    });

    btnDownMerged.addEventListener('click', () => {
      if (!lastMerged) return;
      const header = ['MergedRegion','Channel','N_slices','Avg_Density_per_mm3','Sum_SliceDensity_per_mm3'];
      downloadCSV(lastMerged, 'cfos_density_slice_weighted_avg_by_occurrence.csv', header);
    });

    btnDownSlice.addEventListener('click', () => {
      if (!lastSlice) return;
      const header = ['Image','MergedRegion','Channel','SumArea_mm2','slice_density_mm2','slice_density_mm3'];
      downloadCSV(lastSlice, 'cfos_density_slice_level_weighted.csv', header);
    });

    btnDownMap.addEventListener('click', () => {
      if (!lastMap) return;
      const header = ['AnnotationName','SubRegion','MergedRegion'];
      downloadCSV(lastMap, 'region_merge_mapping.csv', header);
    });

    setStatus('请选择或拖入一个 CSV 文件开始。');
  </script>
</body>
</html>
